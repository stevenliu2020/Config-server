-------------SpringMVC-----------------------------
1 web.xml DispatcherServlet核心控制器自动找WEB-INF下的xx-servelet.xml
2 注册继承Controller类
3 根据上面mapping找到界面
-----
1A）客户端发出http请求进入servlet容器中，容器解析http数据为endpoint对象里面包含http url、http header、body数据流
    然后进入用户自定义的filter，在这里用户可以对request进行处理
    只要请求形式符合web.xml文件中配置的*.do的话，就由DispatcherServlet来处理。
1B）DispatcherServlet再将http请求委托给映射器的对象来将http请求交给对应的【映射器】@RequestMapping来处理
2）映射器根据客户的http请求，再对比<bean name="/hello.do如果匹配正确，再将http请求交给程序员写的@Controller
   这里有个拦截器
3）执行Controller中的业务方法，最终返回一个名叫ModelAndView的对象，其中封装了向视图发送的数据和视图的逻辑名
4）ModelAndView对象随着响应到到DispatcherServlet中了
5）这时DispatcherServlet收到了ModelAndView对象，委托视图解析器的对象去具体解析ModelAndView对象中的内容
6）将视图解析器解析后的内容，再次交由DispatcherServlet核心控制器，这时核心控制器再将请求转发到具体的
   视图页面，取出数据，再显示给用户
---------------------------------------
依赖注入:处理对象的依赖关系
控制反转:IOC对象的创建交给外部容器完成，这个就做控制反转.
---------------zookeeper----4个功能前两个重点---------------------------
1 配置文件集中管理
2 集群管理
3名字服务，4分布式锁 
redis支持的5种数据类型是啥？(String,List,Set,ZSet,Hash)
-------熔断Hystrix-----------------------
熔断与降级区别：
1 触发条件不同，熔断一般是下游服务故障引起的，降级是整体负荷考虑的(减少服务实例)
2 管理目标的层次不同，熔断针对整个框架级的处理，每个微服务都需要服务熔断，无层次区分；
  降级针对业务有层次之分，一般从最外围服务开始
  --------使用Hystrix保护应用-（解决方案超时机制，断路器模式，令牌桶）----------------------------------------
断路器模式：当依赖的请求存在大量超时时，设置超时时间，如果不响应认为异常，没必要
--------设计模式Future---------------------------
--------设计模式Master-Worker--------------------------
---------java.util.concurrent--------------------------
Executor框架
newFixedThreadPool 固定数量的线程池
newSingleThreadExecutor 一个线程的线程池
newCachedThreadPool  根据实际调整数量，60秒后自动收回
newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行
---Concurrent.util常用类--------------------------------
PV网站的总访问量或点击量，UV每台电脑一天一次记录，QPS每秒查询数，RT请求响应时间
峰值qps=(总PV*80%)/(60*60*24*20%)
----------解决高并发在于业务拆分(多域名nginx负载)-----lvs haprox--------------------
1 网络
2 服务  业务 负载做分流
3 java代码限流
-----------------------------------
****************************88888
redis的5种类型 String Hash List Set ZSet
exprie [key] 5 [设置5秒后过期] 用ttl [key]查看过期时间,persist取消过期时间
#netstat -tunpl | grep redis
#ps -el | grep 6379  【这种查看方式后面必须是路径，root无路径的行不算】
-----------
list 
订阅与发布 subscribe  publish
-------BIO同步阻塞，NIO同步非阻塞,AIO异步非阻塞----------------------------
同步：server服务器端的执行方式
阻塞：具体的技术，接收数据的方式、状态(io,nio)
-----------------------------------
同步非阻塞NIO几个概念:Buffer缓冲区、Channel管道、Selector选择器，多路复用器
多个client连1个server
1 传统通过socket点对点的tcp直连，NIO在此之上，client把自己的socketchanner注册到服务器上的selector中
2 服务器端实例化出serverscoketchannel（socket的抽象）
3 selector轮询所有注册的通道，根据通道状态，执行相关操作(connect连接状态、accept阻塞状态、read可读状态、write可写状态)
-----------------------------------
系统高可用：1负载均衡，2 限流措施，3 分布式事务
            4 分布式session 5 压力测试
系统高并发：1 缓存应用 2 HTTP缓存 3 异步并发处理
            4 JVM的优化 5 队列应用 6 动静分离
**********spring boot2*******************************
Reactive中的Flux或者Mono是异步处理(非阻塞)
Flux是0-N个对象集合，Mono是0-1个对象集合
不直接返回集合是因为，集合对象基本上是同步处理
打包-> mvn -Dmaven.test.skip -U clean package
-----------------------------------
1 java源文件通过javac编译成字节码源文件
2 jvm虚拟机先加载class源文件到内存里面，保存到堆里面
3 再有对应系统的jvm虚拟机解析成机器指令

执行的顺序：
1、父类的静态块或者变量 ，按行号先后顺序初始化
2、子类的静态块和变量
3、父类的构造块(无static的块)
4、父类的无参构造方法
5、子类的构造块
6、子类的构造方法，子类的构造方法根据实例化的时候是否传入参数而定
-------------HashMap----------------------------
是一个散列表，存储的是键值对
HashMap：通过hash算法得到的值，定位到这个map，然后把value存到这个map中
初始容量16和加载因子0.75，扩容的方式乘2，即HashMap在put时如果高于或等于0.75做扩容，第一次扩容就是32
如果存入几千的数据，最好做一次性扩容
hashmap是无序的，LinkedHashMap是有序的

ConcurrentHashMap 支持并发,Segment 数组长度为 16，不可以扩容即支持16个并发线程
Segment[i]默认大小2，初始阈值1.5负载因子0.75也就是插入第二个就会扩容
注意HashTable的key和value不能为null，hashmap可以
碰撞：hashcode相同如果key的equals相同直接覆盖value，不同添加到链表中，先添加的放尾部
选用String，Integer这些类做为键会提高HashMap的效率
原理HashMap由数组+链表组成的，数组是HashMap的主体
-----------------------------
分布式下保证ID唯一，由redis生成
session分布式存储在redis中，由token查询
----------不会的面试题-------------------------
http1.0中想建立一个长连接需要在http的请求头中增加Connection: keep-alive,而HTTP/1.1默认是支持长连接的
另外通过httpclient使用HTTP/1.0协议去请求tomcat时，即使带上Connection: keep-alive请求头也保持不了长连接
如果HTTP/1.1版本的http请求报文不希望使用长连接，则要在请求头中加上Connection: close
-----------------------------------
Session分布式共享： 存在 redis中
-----------------------------------
Spring AOP 对于接口使用动态代理机制，普通class通过CGLib派生子类
--------------线程不安全---------------------
StringBuilder - StringBuffer线程安全
SimpleDateFormat- JodaTime线程安全
ArrayList HashSet HashMap等Collections
--------equals ==区别----------------------------------
== 如果是基本数据类型比较的是值相等，如果是对象比较的是内存地址
如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；
诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。
equals方法不能作用于基本数据类型的变量
---------重载不能以返回值区分-----------------------
因为有时不关心返回值
-------servlet----------------
1 web服务器检查是否已经装载了该servlet的实例对象，
  如果没有进行实例化，并调用Init
2 创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，
  然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去，这里调用的doGet doPost方法
3 web应用被停止 执行 destroy
----------反射-------------
把java类中的各个成分映射成一个个的java对象
本质是得到class对象后动态获取属性和动态调用对象的方法
--------Bean生命周期---------------
spring容器开始，spring容器销毁
1 容器寻找Bean的定义并实例化 默认单例
2 Spring对bean进行依赖注入
3 如果bean实现了BeanNameAware接口，spring将bean的id传给setBeanName()方法；
4 如果bean实现了BeanFactoryAware接口，spring将调用setBeanFactory方法，将BeanFactory实例传进来；
5 如果bean实现了ApplicationContextAware接口，它的setApplicationContext()方法将被调用，将应用上下文的引用传入到bean中；
6 如果bean实现了BeanPostProcessor接口，它的postProcessBeforeInitialization方法将被调用；
7 如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet接口方法，类似的如果bean使用了init-method属性声明了初始化方法，该方法也会被调用；
8 如果bean实现了BeanPostProcessor接口，它的postProcessAfterInitialization接口方法将被调用；
9 此时bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁；
10 若bean实现了DisposableBean接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用；
---------------Bean自动配置原理--起步依赖----------------------------
@SpringApplicationBoot包含了@EnableAutoConfiguration，后者借助SpringFactoriesLoader
对classpath下的META-INF/spring-factories下面的一些配置进行了加载
-------------线程的生命周期-----------------------------------------------
新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）
当线程对象调用了start（）方法之后，该线程处于就绪状态
运行 正在执行run方法
死亡 正常run方法结束或者异常调用stop
阻塞 sleep，wait(notify)、suspend(resume)
-----------互斥锁 排它锁，-------------------------------------------------
--------------Spring boot热部署----------------------------
方法1 springloaded
方法2 spring-boot-devtools
--------Mysql主从复制  读写分离---------------------
MySQL主从复制的原理其实就是从服务器读取主服务器的binlog，然后根据binlog的记录来更新数据库
mysql锁的类型：共享锁，排它锁 InnoDB
-----------不走索引------------------
1 Null
2 组合索引没用第一列查询
3 索引列上使用函数
4 列被隐式转化 比如字段是字符串而条件是整数
5 加索引引起full scan
6 <>  or  in  !=   is null不走 is not null 走
7 like %在前面和两个% 后面%走索引
8 查询数量是超过表的一部分,mysql30%,oracle 20%

--------mybatis # $区别---------------------
传入值时#自动加单引号可防止sql注入，后者原样输出
----------List排序-------------------
Collections.sort(names, new Comparator<String>() {重写compare 这个是lambda表达式
ArrayList基于动态数组的数据结构(可增长数组)get快，后者是双链表实现
java基本数据类型 boolean byte short int long float double char
-----------------------------
-----------------------------


